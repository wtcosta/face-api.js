<!DOCTYPE html>
<html>
<head>
  <script src="face-api.js"></script>
  <script src="js/commons.js"></script>
  <script src="js/faceDetectionControls.js"></script>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/css/materialize.css">
  <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/js/materialize.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body>
  <div id="navbar"></div>
  <div class="center-content page-container">

    <div class="progress" id="loader">
      <div class="indeterminate"></div>
    </div>
    
    <div style="position: relative" class="margin">
      <video onloadedmetadata="onPlay(this)" id="inputVideo" autoplay muted playsinline></video>
      <canvas id="overlay" />
    </div>

    <!-- Controles de Hash -->
    <div class="row" style="margin-top: 20px;">
      <div class="col s12">
        <div class="card">
          <div class="card-content">
            <span class="card-title">Configurações de Hash</span>
            <div class="row">
              <div class="col s6">
                <label>Tipo de Hash:</label>
                <select id="hashType" onchange="updateHashDisplay()">
                  <option value="simple">Hash Simples</option>
                  <option value="sha256">SHA-256</option>
                  <option value="md5">MD5</option>
                  <option value="base64">Base64</option>
                  <option value="hex">Hexadecimal</option>
                </select>
              </div>
              <div class="col s6">
                <label>Comprimento do Hash:</label>
                <select id="hashLength" onchange="updateHashDisplay()">
                  <option value="16">16 caracteres</option>
                  <option value="32">32 caracteres</option>
                  <option value="64">64 caracteres</option>
                  <option value="full">Completo</option>
                </select>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Exibição do Hash -->
    <div class="row" style="margin-top: 20px;">
      <div class="col s12">
        <div class="card">
          <div class="card-content">
            <span class="card-title">Hash Facial</span>
            <div id="faceHashDisplay" style="word-break: break-all; font-family: monospace; font-size: 12px; background-color: #f5f5f5; padding: 10px; border-radius: 4px; min-height: 100px;">
              Aguardando detecção de rosto...
            </div>
            <div style="margin-top: 10px;">
              <button class="btn waves-effect waves-light" onclick="copyHash()">
                <i class="material-icons left">content_copy</i>
                Copiar Hash
              </button>
              <button class="btn waves-effect waves-light" onclick="saveHash()">
                <i class="material-icons left">save</i>
                Salvar Hash
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Histórico de Hashes -->
    <div class="row" style="margin-top: 20px;">
      <div class="col s12">
        <div class="card">
          <div class="card-content">
            <span class="card-title">Histórico de Hashes</span>
            <div id="hashHistory" style="max-height: 200px; overflow-y: auto;">
              <p>Nenhum hash salvo ainda.</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="row side-by-side">

      <!-- face_detector_selection_control -->
      <div id="face_detector_selection_control" class="row input-field" style="margin-right: 20px;">
        <select id="selectFaceDetector">
          <option value="ssd_mobilenetv1">SSD Mobilenet V1</option>
          <option value="tiny_face_detector">Tiny Face Detector</option>
        </select>
        <label>Select Face Detector</label>
      </div>
      <!-- face_detector_selection_control -->

      <!-- check boxes -->
      <div class="row" style="width: 220px;">
        <input type="checkbox" id="hideBoundingBoxesCheckbox" onchange="onChangeHideBoundingBoxes(event)" />
        <label for="hideBoundingBoxesCheckbox">Hide Bounding Boxes</label>
      </div>
      <!-- check boxes -->

      <!-- fps_meter -->
      <div id="fps_meter" class="row side-by-side">
        <div>
          <label for="time">Time:</label>
          <input disabled value="-" id="time" type="text" class="bold">
          <label for="fps">Estimated Fps:</label>
          <input disabled value="-" id="fps" type="text" class="bold">
        </div>
      </div>
      <!-- fps_meter -->

    </div>

    <!-- ssd_mobilenetv1_controls -->
    <span id="ssd_mobilenetv1_controls">
      <div class="row side-by-side">
        <div class="row">
          <label for="minConfidence">Min Confidence:</label>
          <input disabled value="0.5" id="minConfidence" type="text" class="bold">
        </div>
        <button
          class="waves-effect waves-light btn"
          onclick="onDecreaseMinConfidence()"
        >
          <i class="material-icons left">-</i>
        </button>
        <button
          class="waves-effect waves-light btn"
          onclick="onIncreaseMinConfidence()"
        >
          <i class="material-icons left">+</i>
        </button>
      </div>
    </span>
    <!-- ssd_mobilenetv1_controls -->

    <!-- tiny_face_detector_controls -->
    <span id="tiny_face_detector_controls">
      <div class="row side-by-side">
        <div class="row input-field" style="margin-right: 20px;">
          <select id="inputSize">
            <option value="" disabled selected>Input Size:</option>
            <option value="128">128 x 128</option>
            <option value="160">160 x 160</option>
            <option value="224">224 x 224</option>
            <option value="320">320 x 320</option>
            <option value="416">416 x 416</option>
            <option value="512">512 x 512</option>
            <option value="608">608 x 608</option>
          </select>
          <label>Input Size</label>
        </div>
        <div class="row">
          <label for="scoreThreshold">Score Threshold:</label>
          <input disabled value="0.5" id="scoreThreshold" type="text" class="bold">
        </div>
        <button
          class="waves-effect waves-light btn"
          onclick="onDecreaseScoreThreshold()"
        >
          <i class="material-icons left">-</i>
        </button>
        <button
          class="waves-effect waves-light btn"
          onclick="onIncreaseScoreThreshold()"
        >
          <i class="material-icons left">+</i>
        </button>
      </div>
    </span>
    <!-- tiny_face_detector_controls -->

  </body>

  <script>
    let forwardTimes = []
    let withBoxes = true
    let lastFaceHash = null
    let lastDescriptor = null
    let hashHistory = []

    // Função para gerar hash simples
    function generateSimpleHash(descriptor) {
      if (!descriptor || descriptor.length === 0) {
        return null
      }
      
      const descriptorString = Array.from(descriptor).join(',')
      let hash = 0
      for (let i = 0; i < descriptorString.length; i++) {
        const char = descriptorString.charCodeAt(i)
        hash = ((hash << 5) - hash) + char
        hash = hash & hash
      }
      
      const hexHash = Math.abs(hash).toString(16).padStart(8, '0')
      const additionalHash = descriptor.slice(0, 16).reduce((acc, val, idx) => {
        return acc + (Math.abs(val * 1000) % 256).toString(16).padStart(2, '0')
      }, '')
      
      return `${hexHash}${additionalHash}`
    }

    // Função para gerar hash SHA-256
    function generateSHA256Hash(descriptor) {
      if (!descriptor || descriptor.length === 0) {
        return null
      }
      
      const descriptorString = Array.from(descriptor).join(',')
      return CryptoJS.SHA256(descriptorString).toString()
    }

    // Função para gerar hash MD5
    function generateMD5Hash(descriptor) {
      if (!descriptor || descriptor.length === 0) {
        return null
      }
      
      const descriptorString = Array.from(descriptor).join(',')
      return CryptoJS.MD5(descriptorString).toString()
    }

    // Função para gerar hash Base64
    function generateBase64Hash(descriptor) {
      if (!descriptor || descriptor.length === 0) {
        return null
      }
      
      const descriptorString = Array.from(descriptor).join(',')
      return btoa(descriptorString)
    }

    // Função para gerar hash Hexadecimal
    function generateHexHash(descriptor) {
      if (!descriptor || descriptor.length === 0) {
        return null
      }
      
      return Array.from(descriptor).map(val => 
        Math.abs(val * 1000).toString(16).padStart(4, '0')
      ).join('')
    }

    // Função principal para gerar hash
    function generateFaceHash(descriptor) {
      if (!descriptor || descriptor.length === 0) {
        return null
      }
      
      const hashType = $('#hashType').val()
      let hash = null
      
      switch (hashType) {
        case 'simple':
          hash = generateSimpleHash(descriptor)
          break
        case 'sha256':
          hash = generateSHA256Hash(descriptor)
          break
        case 'md5':
          hash = generateMD5Hash(descriptor)
          break
        case 'base64':
          hash = generateBase64Hash(descriptor)
          break
        case 'hex':
          hash = generateHexHash(descriptor)
          break
        default:
          hash = generateSimpleHash(descriptor)
      }
      
      // Aplica o comprimento selecionado
      const hashLength = $('#hashLength').val()
      if (hashLength !== 'full' && hash.length > parseInt(hashLength)) {
        hash = hash.substring(0, parseInt(hashLength))
      }
      
      return hash
    }

    // Função para atualizar a exibição do hash
    function updateFaceHashDisplay(descriptor) {
      const hash = generateFaceHash(descriptor)
      const displayElement = $('#faceHashDisplay')
      
      if (hash) {
        lastFaceHash = hash
        lastDescriptor = descriptor
        
        const hashType = $('#hashType').val()
        const hashLength = $('#hashLength').val()
        
        displayElement.html(`
          <strong>Tipo:</strong> ${hashType.toUpperCase()}<br>
          <strong>Comprimento:</strong> ${hashLength === 'full' ? 'Completo' : hashLength + ' caracteres'}<br>
          <strong>Hash Facial:</strong><br>
          <span style="color: #2196F3; font-weight: bold;">${hash}</span><br><br>
          <strong>Descriptor (primeiros 10 valores):</strong><br>
          <span style="font-size: 10px; color: #666;">${descriptor.slice(0, 10).join(', ')}...</span>
        `)
      } else {
        displayElement.html('Nenhum rosto detectado')
      }
    }

    // Função para copiar hash
    function copyHash() {
      if (lastFaceHash) {
        navigator.clipboard.writeText(lastFaceHash).then(() => {
          M.toast({html: 'Hash copiado para a área de transferência!'})
        }).catch(() => {
          M.toast({html: 'Erro ao copiar hash'})
        })
      } else {
        M.toast({html: 'Nenhum hash disponível para copiar'})
      }
    }

    // Função para salvar hash
    function saveHash() {
      if (lastFaceHash && lastDescriptor) {
        const hashEntry = {
          timestamp: new Date().toLocaleString('pt-BR'),
          hash: lastFaceHash,
          type: $('#hashType').val(),
          length: $('#hashLength').val(),
          descriptor: Array.from(lastDescriptor)
        }
        
        hashHistory.push(hashEntry)
        updateHashHistory()
        
        // Salva no localStorage
        localStorage.setItem('faceHashHistory', JSON.stringify(hashHistory))
        
        M.toast({html: 'Hash salvo no histórico!'})
      } else {
        M.toast({html: 'Nenhum hash disponível para salvar'})
      }
    }

    // Função para atualizar histórico
    function updateHashHistory() {
      const historyElement = $('#hashHistory')
      
      if (hashHistory.length === 0) {
        historyElement.html('<p>Nenhum hash salvo ainda.</p>')
        return
      }
      
      let historyHTML = ''
      hashHistory.slice(-5).reverse().forEach((entry, index) => {
        historyHTML += `
          <div style="border-bottom: 1px solid #eee; padding: 10px 0;">
            <strong>${entry.timestamp}</strong><br>
            <span style="color: #2196F3; font-family: monospace; font-size: 11px;">${entry.hash}</span><br>
            <small>Tipo: ${entry.type.toUpperCase()} | Comprimento: ${entry.length}</small>
          </div>
        `
      })
      
      historyElement.html(historyHTML)
    }

    // Função para atualizar exibição quando configurações mudam
    function updateHashDisplay() {
      if (lastDescriptor) {
        updateFaceHashDisplay(lastDescriptor)
      }
    }

    function onChangeHideBoundingBoxes(e) {
      withBoxes = !$(e.target).prop('checked')
    }

    function updateTimeStats(timeInMs) {
      forwardTimes = [timeInMs].concat(forwardTimes).slice(0, 30)
      const avgTimeInMs = forwardTimes.reduce((total, t) => total + t) / forwardTimes.length
      $('#time').val(`${Math.round(avgTimeInMs)} ms`)
      $('#fps').val(`${faceapi.utils.round(1000 / avgTimeInMs)}`)
    }

    async function onPlay() {
      const videoEl = $('#inputVideo').get(0)

      if(videoEl.paused || videoEl.ended || !isFaceDetectionModelLoaded())
        return setTimeout(() => onPlay())

      const options = getFaceDetectorOptions()

      const ts = Date.now()

      // Detecta face com landmarks e descriptor
      const result = await faceapi.detectSingleFace(videoEl, options)
        .withFaceLandmarks()
        .withFaceDescriptor()

      updateTimeStats(Date.now() - ts)

      if (result) {
        const canvas = $('#overlay').get(0)
        const dims = faceapi.matchDimensions(canvas, videoEl, true)
        const resizedResult = faceapi.resizeResults(result, dims)

        if (withBoxes) {
          faceapi.draw.drawDetections(canvas, resizedResult)
        }
        faceapi.draw.drawFaceLandmarks(canvas, resizedResult)
        
        // Atualiza o hash facial
        updateFaceHashDisplay(result.descriptor)
      } else {
        // Se nenhum rosto for detectado, limpa a exibição
        $('#faceHashDisplay').html('Nenhum rosto detectado')
      }

      setTimeout(() => onPlay())
    }

    async function run() {
      // load face detection, face landmark model and face recognition models
      await changeFaceDetector(TINY_FACE_DETECTOR)
      await faceapi.loadFaceLandmarkModel('/')
      await faceapi.loadFaceRecognitionModel('/')
      changeInputSize(224)

      // try to access users webcam and stream the images
      // to the video element
      const stream = await navigator.mediaDevices.getUserMedia({ video: {} })
      const videoEl = $('#inputVideo').get(0)
      videoEl.srcObject = stream
    }

    function updateResults() {}

    $(document).ready(function() {
      renderNavBar('#navbar', 'webcam_face_hash')
      initFaceDetectionControls()
      
      // Carrega histórico do localStorage
      const savedHistory = localStorage.getItem('faceHashHistory')
      if (savedHistory) {
        hashHistory = JSON.parse(savedHistory)
        updateHashHistory()
      }
      
      run()
    })
  </script>
</body>
</html>
